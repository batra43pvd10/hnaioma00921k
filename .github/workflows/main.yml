name: Docker with Continuous Logging
'on':
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      part:
        description: 'Part number (01, 02, etc.)'
        required: false
        default: '01'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Pull Docker image
        run: 'docker pull ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest'
      
      - name: Setup logging directories
        run: |
          mkdir -p ~/logs
          mkdir -p ~/cloudflared
          touch ~/logs/app.log
          touch ~/logs/monitor.log
          touch ~/cloudflared/tunnel.log
          echo "Logging setup complete"
      
      - name: Install Cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/
          echo "Cloudflared installed"
      
      - name: Start Docker container with logging
        run: |
          echo "Starting container..."
          docker run -d \
            -p 5001:5001 \
            --name api-container \
            --restart unless-stopped \
            ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest
          
          echo "Container started, waiting for initialization..."
          sleep 15
          
          # Test container
          if docker ps | grep -q api-container; then
            echo "Container is running"
            docker logs api-container
          else
            echo "Container failed to start"
            docker ps -a
            exit 1
          fi
      
      - name: Start background log monitoring
        run: |
          # Create background monitoring script
          cat > ~/monitor.sh << 'EOF'
          #!/bin/bash
          while true; do
            echo "=== $(date) ===" >> ~/logs/monitor.log
            
            # Check container status
            if docker ps | grep -q api-container; then
              echo "Container: RUNNING" >> ~/logs/monitor.log
              docker logs api-container --tail 10 >> ~/logs/app.log 2>&1
            else
              echo "Container: STOPPED" >> ~/logs/monitor.log
              docker ps -a | grep api-container >> ~/logs/monitor.log
            fi
            
            # Rotate logs if too large (>10MB)
            for logfile in ~/logs/*.log; do
              if [ -f "$logfile" ] && [ $(stat -c%s "$logfile" 2>/dev/null || echo 0) -gt 10485760 ]; then
                mv "$logfile" "${logfile}.$(date +%s)"
                touch "$logfile"
              fi
            done
            
            sleep 30
          done
          EOF
          
          chmod +x ~/monitor.sh
          ~/monitor.sh &
          echo "Background monitoring started"
      
      - name: Setup Cloudflare tunnel
        run: |
          echo "Starting Cloudflare tunnel..."
          cloudflared tunnel --url http://localhost:5001 --logfile ~/cloudflared/tunnel.log &
          TUNNEL_PID=$!
          
          # Wait for tunnel initialization
          sleep 20
          
          # Extract tunnel URL
          if [ -f ~/cloudflared/tunnel.log ]; then
            TUNNEL_URL=$(grep -o 'https://[a-zA-Z0-9.-]*\.trycloudflare\.com' ~/cloudflared/tunnel.log | tail -1)
            
            if [ -n "$TUNNEL_URL" ]; then
              echo "Tunnel URL: $TUNNEL_URL"
              echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV
              echo "::notice::Application available at: $TUNNEL_URL"
            else
              echo "Failed to get tunnel URL"
              cat ~/cloudflared/tunnel.log
            fi
          else
            echo "Tunnel log file not found"
          fi
      
      - name: Test application
        run: |
          echo "Testing application..."
          
          # Test local connection
          curl -s http://localhost:5001/ || echo "Local test failed"
          
          # Test tunnel connection
          if [ -n "${{ env.TUNNEL_URL }}" ]; then
            sleep 10
            curl -s ${{ env.TUNNEL_URL }}/ || echo "Tunnel test failed"
          fi
      
      - name: Update repository status
        if: env.TUNNEL_URL != ''
        run: |
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
          
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "{\"repository_name\":\"$REPO_NAME\",\"status\":\"Active\",\"cloudflare_tunnel_url\":\"${{ env.TUNNEL_URL }}\"}" \
            https://update-repository-status.vercel.app/api/update_repository_status || echo "Status update failed"
      
      - name: Start log display service
        run: |
          # Simple HTTP server to display logs
          cat > ~/log_server.py << 'EOF'
          #!/usr/bin/env python3
          import http.server
          import socketserver
          import os
          
          class LogHandler(http.server.SimpleHTTPRequestHandler):
              def do_GET(self):
                  if self.path == '/logs':
                      self.send_response(200)
                      self.send_header('Content-type', 'text/plain')
                      self.end_headers()
                      
                      try:
                          with open(os.path.expanduser('~/logs/app.log'), 'r') as f:
                              content = f.read()
                              self.wfile.write(content.encode())
                      except:
                          self.wfile.write(b'No logs available')
                  
                  elif self.path == '/monitor':
                      self.send_response(200)
                      self.send_header('Content-type', 'text/plain')
                      self.end_headers()
                      
                      try:
                          with open(os.path.expanduser('~/logs/monitor.log'), 'r') as f:
                              content = f.read()
                              self.wfile.write(content.encode())
                      except:
                          self.wfile.write(b'No monitor logs available')
                  else:
                      self.send_response(404)
                      self.end_headers()
          
          with socketserver.TCPServer(("", 8080), LogHandler) as httpd:
              httpd.serve_forever()
          EOF
          
          # Start log server in background
          python3 ~/log_server.py &
          echo "Log server started on port 8080"
      
      - name: Display access information
        run: |
          echo "================================="
          echo "APPLICATION ACCESS INFORMATION"
          echo "================================="
          echo "Main Application: ${{ env.TUNNEL_URL }}"
          echo "Application Logs: ${{ env.TUNNEL_URL }}:8080/logs (if port 8080 is accessible)"
          echo "Monitor Logs: ${{ env.TUNNEL_URL }}:8080/monitor"
          echo ""
          echo "Container Status:"
          docker ps | grep api-container || echo "Container not running"
          echo ""
          echo "Recent Application Logs:"
          docker logs api-container --tail 20 || echo "Cannot fetch logs"
      
      - name: Monitor and keep alive
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Starting 30-minute monitoring session..."
          
          # Monitor for 30 minutes with status updates every 2 minutes
          for i in {1..15}; do
            echo ""
            echo "=== Status Update $i/15 ($(date)) ==="
            
            # Container status
            if docker ps | grep -q api-container; then
              echo "✓ Container is running"
            else
              echo "✗ Container is not running"
              docker ps -a | grep api-container
            fi
            
            # Tunnel connectivity
            if [ -n "${{ env.TUNNEL_URL }}" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" ${{ env.TUNNEL_URL }}/ || echo "000")
              if [ "$HTTP_CODE" = "200" ]; then
                echo "✓ Tunnel is accessible (HTTP $HTTP_CODE)"
              else
                echo "✗ Tunnel issue (HTTP $HTTP_CODE)"
              fi
            fi
            
            # Recent logs
            echo "Recent container output:"
            docker logs api-container --tail 3 2>&1 | head -3
            
            # Log file sizes
            echo "Log file sizes:"
            ls -lh ~/logs/*.log 2>/dev/null | awk '{print $5, $9}' || echo "No log files"
            
            echo "Waiting 2 minutes..."
            sleep 120
          done
          
          echo "Monitoring session complete"
      
      - name: Collect final logs
        if: always()
        run: |
          echo "Collecting final logs..."
          
          mkdir -p ~/final_logs
          
          # Copy all logs
          cp ~/logs/*.log ~/final_logs/ 2>/dev/null || echo "No app logs to copy"
          cp ~/cloudflared/tunnel.log ~/final_logs/ 2>/dev/null || echo "No tunnel log to copy"
          
          # Get final container state
          echo "=== Final Container Status ===" > ~/final_logs/container_status.txt
          docker ps -a >> ~/final_logs/container_status.txt
          
          echo "=== Final Container Logs ===" > ~/final_logs/final_container.log
          docker logs api-container >> ~/final_logs/final_container.log 2>&1 || echo "Cannot get container logs"
          
          # Create summary
          echo "Workflow: ${{ github.workflow }}" > ~/final_logs/summary.txt
          echo "Run ID: ${{ github.run_id }}" >> ~/final_logs/summary.txt
          echo "Repository: ${{ github.repository }}" >> ~/final_logs/summary.txt
          echo "Tunnel URL: ${{ env.TUNNEL_URL }}" >> ~/final_logs/summary.txt
          echo "Timestamp: $(date)" >> ~/final_logs/summary.txt
          
          echo "Final logs collected:"
          ls -la ~/final_logs/
      
      - name: Archive logs
        if: always()
        run: |
          # Create tar archive of all logs
          cd ~
          tar -czf workflow-logs-${{ github.run_id }}.tar.gz final_logs/
          
          echo "Log archive created:"
          ls -lh workflow-logs-*.tar.gz
          
          # Display archive contents
          echo "Archive contents:"
          tar -tzf workflow-logs-${{ github.run_id }}.tar.gz
      
      - name: Sleep before next iteration
        run: |
          echo "Sleeping for 5 hours..."
          sleep 18000

  trigger_next:
    needs: deploy
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Get next part number
        id: next_part
        run: |
          CURRENT_PART="${{ github.event.inputs.part || '01' }}"
          NEXT_PART=$(printf "%02d" $((10#$CURRENT_PART + 1)))
          echo "next_part=$NEXT_PART" >> $GITHUB_OUTPUT
          echo "Next part will be: $NEXT_PART"
      
      - name: Trigger next workflow
        run: |
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/${{ github.workflow }}/dispatches \
            -d '{"ref":"${{ github.ref_name }}","inputs":{"part":"${{ steps.next_part.outputs.next_part }}"}}'
