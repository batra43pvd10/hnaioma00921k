name: Pull Private Docker Image with Log Viewer

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      part:
        description: 'Part number (01, 02, etc.)'
        required: false
        default: '01'

jobs:
  deploy:
    runs-on: ubuntu-latest
    # N·∫øu b·∫°n mu·ªën workflow ch·∫°y l√¢u h∆°n (t·ªëi ƒëa 6h)
    timeout-minutes: 360

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Pull Docker image
        run: docker pull ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest

      - name: List Docker images
        run: docker images ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest

      - name: Install Cloudflared
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 \
            -o cloudflared
          chmod +x cloudflared
          sudo mv cloudflared /usr/local/bin/

      - name: Run container, log to file & serve via HTTP + Tunnel
        shell: bash
        run: |
          echo "::group::üöÄ Start container + log to file + serve logs via HTTP + Tunnel"

          # 1) Chu·∫©n b·ªã th∆∞ m·ª•c ch·ª©a logs
          mkdir -p /tmp/logs

          # 2) Ch·∫°y container detached, redirect stdout/stderr v√†o file
          docker run -d --name api-container -p 5001:5001 \
            ${{ secrets.DOCKERHUB_IMAGE_URL }}:latest \
            > /tmp/logs/app.log 2>&1

          # 3) M·ªü HTTP server serve /tmp/logs tr√™n c·ªïng 8000
          nohup python3 -m http.server 8000 --directory /tmp/logs \
            >/tmp/logs/http.log 2>&1 &
          
          # 4) T·∫°o Cloudflare Tunnel tr·ªè t·ªõi HTTP server
          cloudflared tunnel --url http://localhost:8000 --loglevel debug &
          
          # 5) ƒê·ª£i tunnel kh·ªüi, tr√≠ch URL v√† l∆∞u v√†o m√¥i tr∆∞·ªùng
          sleep 5
          TUNNEL_URL=$(grep -o 'https://[a-zA-Z0-9.-]*\.trycloudflare\.com' \
            <(ps aux | grep cloudflared) | tail -1)
          echo "::notice::Log viewer URL: $TUNNEL_URL"
          echo "TUNNEL_URL=$TUNNEL_URL" >> $GITHUB_ENV

          echo "::endgroup::"

      - name: Verify API through tunnel
        run: |
          echo "Health check via tunnel:"
          curl -fs ${{ env.TUNNEL_URL }}/health || echo "API status check failed but continuing"

      - name: Update repository status in flask_github_manager_final
        if: success() && env.TUNNEL_URL != ''
        run: |
          REPO_NAME=$(echo "$GITHUB_REPOSITORY" | cut -d'/' -f2)
          JSON_PAYLOAD=$(cat << EOF
          {
            "repository_name": "$REPO_NAME",
            "status": "Active",
            "cloudflare_tunnel_url": "${{ env.TUNNEL_URL }}"
          }
          EOF
          )
          curl -X POST \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            https://update-repository-status.vercel.app/api/update_repository_status
          echo "::notice::Repository status updated in flask_github_manager_final"

      - name: Keep container and tunnel running for monitoring (workflow_dispatch only)
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Container v√† tunnel s·∫Ω ch·∫°y th√™m 30 ph√∫t ƒë·ªÉ gi√°m s√°t."
          sleep 1800

      - name: Tail recent application logs
        run: |
          echo "---- Last 50 lines of app.log ----"
          tail -n 50 /tmp/logs/app.log

      - name: Wait 5 hours before triggering next build
        run: |
          echo "Sleeping for 5 hours before re-dispatching workflow..."
          sleep 18000

  trigger_next:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Trigger next chunk
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const currentPart = context.payload.inputs?.part || '01';
            const next = String(parseInt(currentPart, 10) + 1).padStart(2, '0');
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: context.workflow,
              ref: context.ref.replace('refs/heads/', ''),
              inputs: { part: next }
            });
